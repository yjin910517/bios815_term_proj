# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' A function to decompose rating matrix with missing values through stochastic gradient descent
#' 
#' @param X A (n*p) user by item rating matrix. Missing ratings should be represented
#'  as 0. Non-missing ratings should be re-scale to exclude zero.
#' @param n_features Dimension of each factor vector
#' @param alpha Learning rate
#' @param gamma Regularization parameter
#' @param tol Tolerance for convergence checking
#' @param max_iter Maximum iterations 
#' @return A list of following outputs:
#' \item{U}{A (n*k) matrix of n user factors}
#' \item{V}{A (p*k) matrix of p item factors}
#' \item{Iterations}{Numer of iterations operated}  
#' \item{Errors}{Root mean square error (RMSE) of the last iteration}
#' @examples
#' # Example code for Funk SVD
#' data("MovieLenseSub") # A subset of MovieLense Data
#' train <- MovieLenseSub[1:200,1:500]
#' train[is.na(train)]<-0
#' 
#' res<-funk_svd(train,max_iter=2000)
#' 
#' users<-c(1,2,3)
#' items<-c(4,5,6,7)
#' 
#' funk_predict(res$U,res$V,users-1,items-1)
funk_svd <- function(X, n_features = 10L, alpha = 0.001, gamma = 0.015, tol = 1.0e-6, max_iter = 200L) {
    .Call(`_recommendeRcpp_funk_svd`, X, n_features, alpha, gamma, tol, max_iter)
}

#' A function to predict ratings of given users and items from Funk SVD factors
#' 
#' @param U A (n*k) matrix of n user factors, output from funk_svd()
#' @param V A (p*k) matrix of p item factors, output from funk_svd()
#' @param users A u length vector that contains zero-based indices of selected users
#' @param items A i length vector taht contains zero-based indices of selected items
#' @return A (u*i) matrix with predicted ratings of i items from u users 
#' @examples
#' # Example code for Funk SVD
#' data("MovieLenseSub") # A subset of MovieLense Data
#' train <- MovieLenseSub[1:200,1:500]
#' train[is.na(train)]<-0
#' 
#' res<-funk_svd(train,max_iter=2000)
#' 
#' users<-c(1,2,3)
#' items<-c(4,5,6,7)
#' 
#' funk_predict(res$U,res$V,users-1,items-1)
funk_predict <- function(U, V, users, items) {
    .Call(`_recommendeRcpp_funk_predict`, U, V, users, items)
}

#' A function to remove individual rating bias from each user
#' 
#' @param train A (n*p) user*item rating matrix from training users
#' @param test A (m*p) user*item rating matrix from testing users
#' @return A list of following outputs:
#' \item{train_norm}{A (n*p) normalized rating matrix for training users}
#' \item{test_norm}{A (m*p) normalized rating matrix for testing users}
#' \item{test_Center}{A m length vector with the mean rating of each testing user}
normalize <- function(train, test) {
    .Call(`_recommendeRcpp_normalize`, train, test)
}

#' A function to calculate the pairwise cosine similarity between two matrices
#' 
#' @param A A (n*p) user*item rating matrix 
#' @param B A (m*p) user*item rating matrix
#' @return A (m*n) matrix, where (i,j) element representing the cosine similarity 
#' between row vector A_j and row vector B_i  
cos_similarity <- function(A, B) {
    .Call(`_recommendeRcpp_cos_similarity`, A, B)
}

#' A function to predict (normalized) ratings given k nearest neighbors of testing users
#' 
#' @param sim A (m*n) matrix that contains the pairwise similarity 
#' between m testing users and n training users, output of function cos_similarity()
#' @param neighbors A (m*k) matrix, each row contains the index of 
#' k nearest neighbors of testing users, output of function get_neighbors()
#' @param train A (n*p) rating matrix from n users of training set 
#' @return A (m*p) matrix of predicted ratings for m testing users on all items
predict_u <- function(sim, neighbors, train) {
    .Call(`_recommendeRcpp_predict_u`, sim, neighbors, train)
}

